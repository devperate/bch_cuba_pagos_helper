(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],3:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Semaphore_1 = require("./Semaphore");
var Mutex = /** @class */ (function () {
    function Mutex(cancelError) {
        this._semaphore = new Semaphore_1.default(1, cancelError);
    }
    Mutex.prototype.acquire = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, releaser;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this._semaphore.acquire()];
                    case 1:
                        _a = _b.sent(), releaser = _a[1];
                        return [2 /*return*/, releaser];
                }
            });
        });
    };
    Mutex.prototype.runExclusive = function (callback) {
        return this._semaphore.runExclusive(function () { return callback(); });
    };
    Mutex.prototype.isLocked = function () {
        return this._semaphore.isLocked();
    };
    Mutex.prototype.waitForUnlock = function () {
        return this._semaphore.waitForUnlock();
    };
    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */
    Mutex.prototype.release = function () {
        this._semaphore.release();
    };
    Mutex.prototype.cancel = function () {
        return this._semaphore.cancel();
    };
    return Mutex;
}());
exports.default = Mutex;

},{"./Semaphore":5,"tslib":15}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var errors_1 = require("./errors");
var Semaphore = /** @class */ (function () {
    function Semaphore(_maxConcurrency, _cancelError) {
        if (_cancelError === void 0) { _cancelError = errors_1.E_CANCELED; }
        this._maxConcurrency = _maxConcurrency;
        this._cancelError = _cancelError;
        this._queue = [];
        this._waiters = [];
        if (_maxConcurrency <= 0) {
            throw new Error('semaphore must be initialized to a positive value');
        }
        this._value = _maxConcurrency;
    }
    Semaphore.prototype.acquire = function () {
        var _this = this;
        var locked = this.isLocked();
        var ticketPromise = new Promise(function (resolve, reject) {
            return _this._queue.push({ resolve: resolve, reject: reject });
        });
        if (!locked)
            this._dispatch();
        return ticketPromise;
    };
    Semaphore.prototype.runExclusive = function (callback) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, value, release;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.acquire()];
                    case 1:
                        _a = _b.sent(), value = _a[0], release = _a[1];
                        _b.label = 2;
                    case 2:
                        _b.trys.push([2, , 4, 5]);
                        return [4 /*yield*/, callback(value)];
                    case 3: return [2 /*return*/, _b.sent()];
                    case 4:
                        release();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Semaphore.prototype.waitForUnlock = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var waitPromise;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_a) {
                if (!this.isLocked()) {
                    return [2 /*return*/, Promise.resolve()];
                }
                waitPromise = new Promise(function (resolve) { return _this._waiters.push({ resolve: resolve }); });
                return [2 /*return*/, waitPromise];
            });
        });
    };
    Semaphore.prototype.isLocked = function () {
        return this._value <= 0;
    };
    /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */
    Semaphore.prototype.release = function () {
        if (this._maxConcurrency > 1) {
            throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');
        }
        if (this._currentReleaser) {
            var releaser = this._currentReleaser;
            this._currentReleaser = undefined;
            releaser();
        }
    };
    Semaphore.prototype.cancel = function () {
        var _this = this;
        this._queue.forEach(function (ticket) { return ticket.reject(_this._cancelError); });
        this._queue = [];
    };
    Semaphore.prototype._dispatch = function () {
        var _this = this;
        var nextTicket = this._queue.shift();
        if (!nextTicket)
            return;
        var released = false;
        this._currentReleaser = function () {
            if (released)
                return;
            released = true;
            _this._value++;
            _this._resolveWaiters();
            _this._dispatch();
        };
        nextTicket.resolve([this._value--, this._currentReleaser]);
    };
    Semaphore.prototype._resolveWaiters = function () {
        this._waiters.forEach(function (waiter) { return waiter.resolve(); });
        this._waiters = [];
    };
    return Semaphore;
}());
exports.default = Semaphore;

},{"./errors":6,"tslib":15}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.E_CANCELED = exports.E_ALREADY_LOCKED = exports.E_TIMEOUT = void 0;
exports.E_TIMEOUT = new Error('timeout while waiting for mutex to become available');
exports.E_ALREADY_LOCKED = new Error('mutex already locked');
exports.E_CANCELED = new Error('request for lock canceled');

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryAcquire = exports.withTimeout = exports.Semaphore = exports.Mutex = void 0;
var tslib_1 = require("tslib");
var Mutex_1 = require("./Mutex");
Object.defineProperty(exports, "Mutex", { enumerable: true, get: function () { return Mutex_1.default; } });
var Semaphore_1 = require("./Semaphore");
Object.defineProperty(exports, "Semaphore", { enumerable: true, get: function () { return Semaphore_1.default; } });
var withTimeout_1 = require("./withTimeout");
Object.defineProperty(exports, "withTimeout", { enumerable: true, get: function () { return withTimeout_1.withTimeout; } });
var tryAcquire_1 = require("./tryAcquire");
Object.defineProperty(exports, "tryAcquire", { enumerable: true, get: function () { return tryAcquire_1.tryAcquire; } });
(0, tslib_1.__exportStar)(require("./errors"), exports);

},{"./Mutex":4,"./Semaphore":5,"./errors":6,"./tryAcquire":8,"./withTimeout":9,"tslib":15}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryAcquire = void 0;
var errors_1 = require("./errors");
var withTimeout_1 = require("./withTimeout");
// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types
function tryAcquire(sync, alreadyAcquiredError) {
    if (alreadyAcquiredError === void 0) { alreadyAcquiredError = errors_1.E_ALREADY_LOCKED; }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (0, withTimeout_1.withTimeout)(sync, 0, alreadyAcquiredError);
}
exports.tryAcquire = tryAcquire;

},{"./errors":6,"./withTimeout":9}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withTimeout = void 0;
var tslib_1 = require("tslib");
var errors_1 = require("./errors");
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function withTimeout(sync, timeout, timeoutError) {
    var _this = this;
    if (timeoutError === void 0) { timeoutError = errors_1.E_TIMEOUT; }
    return {
        acquire: function () {
            return new Promise(function (resolve, reject) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                var isTimeout, handle, ticket, release, e_1;
                return (0, tslib_1.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            isTimeout = false;
                            handle = setTimeout(function () {
                                isTimeout = true;
                                reject(timeoutError);
                            }, timeout);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, sync.acquire()];
                        case 2:
                            ticket = _a.sent();
                            if (isTimeout) {
                                release = Array.isArray(ticket) ? ticket[1] : ticket;
                                release();
                            }
                            else {
                                clearTimeout(handle);
                                resolve(ticket);
                            }
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            if (!isTimeout) {
                                clearTimeout(handle);
                                reject(e_1);
                            }
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); });
        },
        runExclusive: function (callback) {
            return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
                var release, ticket;
                return (0, tslib_1.__generator)(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            release = function () { return undefined; };
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 7, 8]);
                            return [4 /*yield*/, this.acquire()];
                        case 2:
                            ticket = _a.sent();
                            if (!Array.isArray(ticket)) return [3 /*break*/, 4];
                            release = ticket[1];
                            return [4 /*yield*/, callback(ticket[0])];
                        case 3: return [2 /*return*/, _a.sent()];
                        case 4:
                            release = ticket;
                            return [4 /*yield*/, callback()];
                        case 5: return [2 /*return*/, _a.sent()];
                        case 6: return [3 /*break*/, 8];
                        case 7:
                            release();
                            return [7 /*endfinally*/];
                        case 8: return [2 /*return*/];
                    }
                });
            });
        },
        /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */
        release: function () {
            sync.release();
        },
        cancel: function () {
            return sync.cancel();
        },
        waitForUnlock: function () { return sync.waitForUnlock(); },
        isLocked: function () { return sync.isLocked(); },
    };
}
exports.withTimeout = withTimeout;

},{"./errors":6,"tslib":15}],10:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":11,"_process":3}],11:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":14}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug$1 = require('debug');
var events = require('events');
var tls = require('tls');
var net = require('net');
var WebSocket = require('isomorphic-ws');
var asyncMutex = require('async-mutex');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var tls__default = /*#__PURE__*/_interopDefaultLegacy(tls);
var net__default = /*#__PURE__*/_interopDefaultLegacy(net);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);

// Create the debug logs.
const debug = {
    client: debug$1.debug('electrum-cash:client '),
    cluster: debug$1.debug('electrum-cash:cluster'),
    errors: debug$1.debug('electrum-cash:error  '),
    warning: debug$1.debug('electrum-cash:warning'),
    network: debug$1.debug('electrum-cash:network'),
    ping: debug$1.debug('electrum-cash:pulses '),
};
// Set log colors.
debug.client.color = '2';
debug.cluster.color = '3';
debug.errors.color = '9';
debug.warning.color = '13';
debug.network.color = '4';
debug.ping.color = '8';

/**
 * Grouping of utilities that simplifies implementation of the Electrum protocol.
 *
 * @ignore
 */
class ElectrumProtocol {
    /**
     * Helper function that builds an Electrum request object.
     *
     * @param {string} method       method to call.
     * @param {array}  parameters   method parameters for the call.
     * @param {string} requestId    unique string or number referencing this request.
     *
     * @returns a properly formatted Electrum request string.
     */
    static buildRequestObject(method, parameters, requestId) {
        // Return the formatted request object.
        // NOTE: Electrum either uses JsonRPC strictly or loosely.
        //       If we specify protocol identifier without being 100% compliant, we risk being disconnected/blacklisted.
        //       For this reason, we omit the protocol identifier to avoid issues.
        return JSON.stringify({ method: method, params: parameters, id: requestId });
    }
    /**
     * Constant used to verify if a provided string is a valid version number.
     *
     * @returns a regular expression that matches valid version numbers.
     */
    static get versionRegexp() {
        return /^\d+(\.\d+)+$/;
    }
    /**
     * Constant used to separate statements/messages in a stream of data.
     *
     * @returns the delimiter used by Electrum to separate statements.
     */
    static get statementDelimiter() {
        return '\n';
    }
}

const isVersionRejected = function (object) {
    return 'error' in object;
};
const isVersionNegotiated = function (object) {
    return 'software' in object && 'protocol' in object;
};

// Disable indent rule for this file because it is broken (https://github.com/typescript-eslint/typescript-eslint/issues/1824)
/* eslint-disable @typescript-eslint/indent */
/**
 * Enum that denotes the ordering to use in an ElectrumCluster.
 * @enum {number}
 * @property {0} RANDOM     Send requests to randomly selected servers in the cluster.
 * @property {1} PRIORITY   Send requests to servers in the cluster in the order they were added.
 */
exports.ClusterOrder = void 0;
(function (ClusterOrder) {
    ClusterOrder[ClusterOrder["RANDOM"] = 0] = "RANDOM";
    ClusterOrder[ClusterOrder["PRIORITY"] = 1] = "PRIORITY";
})(exports.ClusterOrder || (exports.ClusterOrder = {}));
/**
 * Enum that denotes the distribution setting to use in an ElectrumCluster.
 * @enum {number}
 * @property {0} ALL   Send requests to all servers in the cluster.
 */
exports.ClusterDistribution = void 0;
(function (ClusterDistribution) {
    ClusterDistribution[ClusterDistribution["ALL"] = 0] = "ALL";
})(exports.ClusterDistribution || (exports.ClusterDistribution = {}));
/**
 * Enum that denotes the ready status of an ElectrumCluster.
 * @enum {number}
 * @property {0} DISABLED    The cluster is disabled and unusable.
 * @property {1} DEGRADED    The cluster is degraded but still usable.
 * @property {2} READY       The cluster is healthy and ready for use.
 */
exports.ClusterStatus = void 0;
(function (ClusterStatus) {
    ClusterStatus[ClusterStatus["DISABLED"] = 0] = "DISABLED";
    ClusterStatus[ClusterStatus["DEGRADED"] = 1] = "DEGRADED";
    ClusterStatus[ClusterStatus["READY"] = 2] = "READY";
})(exports.ClusterStatus || (exports.ClusterStatus = {}));
/**
 * Enum that denotes the availability of an ElectrumClient.
 * @enum {number}
 * @property {0} UNAVAILABLE   The client is currently not available.
 * @property {1} AVAILABLE     The client is available for use.
 */
exports.ClientState = void 0;
(function (ClientState) {
    ClientState[ClientState["UNAVAILABLE"] = 0] = "UNAVAILABLE";
    ClientState[ClientState["AVAILABLE"] = 1] = "AVAILABLE";
})(exports.ClientState || (exports.ClientState = {}));
/**
 * Enum that denotes the connection status of an ElectrumConnection.
 * @enum {number}
 * @property {0} DISCONNECTED    The connection is disconnected.
 * @property {1} AVAILABLE       The connection is connected.
 * @property {2} DISCONNECTING   The connection is disconnecting.
 * @property {3} CONNECTING      The connection is connecting.
 * @property {4} RECONNECTING    The connection is restarting.
 */
exports.ConnectionStatus = void 0;
(function (ConnectionStatus) {
    ConnectionStatus[ConnectionStatus["DISCONNECTED"] = 0] = "DISCONNECTED";
    ConnectionStatus[ConnectionStatus["CONNECTED"] = 1] = "CONNECTED";
    ConnectionStatus[ConnectionStatus["DISCONNECTING"] = 2] = "DISCONNECTING";
    ConnectionStatus[ConnectionStatus["CONNECTING"] = 3] = "CONNECTING";
    ConnectionStatus[ConnectionStatus["RECONNECTING"] = 4] = "RECONNECTING";
})(exports.ConnectionStatus || (exports.ConnectionStatus = {}));

/**
 * Object containing the commonly used ports and schemes for specific Transports.
 * @example const electrum = new ElectrumClient('Electrum client example', '1.4.1', 'bch.imaginary.cash', Transport.WSS.Port, Transport.WSS.Scheme);
 *
 * @property {object} TCP       Port and Scheme to use unencrypted TCP sockets.
 * @property {object} TCP_TLS   Port and Scheme to use TLS-encrypted TCP sockets.
 * @property {object} WS        Port and Scheme to use unencrypted WebSockets.
 * @property {object} WSS       Port and Scheme to use TLS-encrypted WebSockets.
 */
const ElectrumTransport = {
    TCP: { Port: 50001, Scheme: 'tcp' },
    TCP_TLS: { Port: 50002, Scheme: 'tcp_tls' },
    WS: { Port: 50003, Scheme: 'ws' },
    WSS: { Port: 50004, Scheme: 'wss' },
};
const DefaultParameters = {
    // Port number for TCP TLS connections
    PORT: ElectrumTransport.TCP_TLS.Port,
    // Transport to connect to the Electrum server
    TRANSPORT_SCHEME: ElectrumTransport.TCP_TLS.Scheme,
    // How long to wait before attempting to reconnect, in milliseconds.
    RECONNECT: 15 * 1000,
    // How long to wait for network operations before following up, in milliseconds.
    TIMEOUT: 120 * 1000,
    // Time between ping messages, in milliseconds. Pinging keeps the connection alive.
    // The reason for pinging this frequently is to detect connection problems early.
    PING_INTERVAL: 3 * 1000,
    // How many servers are required before we trust information provided.
    CLUSTER_CONFIDENCE: 1,
    // How many servers we send requests to.
    CLUSTER_DISTRIBUTION: exports.ClusterDistribution.ALL,
    // What order we select servers to send requests to.
    CLUSTER_ORDER: exports.ClusterOrder.RANDOM,
};

/**
 * Isomorphic Socket interface supporting TCP sockets and WebSockets (Node and browser).
 * The interface is a subset of the TLSSocket interface with some slight modifications.
 * It can be expanded when more socket functionality is needed in the rest of the
 * electrum-cash code. Changes from the TLSSocket interface (besides it being a subset):
 * - Event 'close' -> 'disconnect'
 * - New function socket.disconnect()
 *
 * @ignore
 */
class ElectrumSocket extends events.EventEmitter {
    // Declare an empty TCP socket.
    tcpSocket;
    // Declare an empty WebSocket.
    webSocket;
    // Declare timers for keep-alive pings and reconnection
    timers = {};
    // Initialize boolean that indicates whether the onConnect function has run (initialize to false).
    onConnectHasRun = false;
    // Initialize event forwarding functions.
    eventForwarders = {
        disconnect: () => this.emit('disconnect'),
        tcpData: (data) => this.emit('data', data),
        wsData: (event) => this.emit('data', `${event.data}\n`),
        tcpError: (err) => this.emit('error', err),
        wsError: (event) => this.emit('error', event.error),
    };
    /**
     * Connect to host:port using the specified transport
     *
     * @param {string} host              Fully qualified domain name or IP address of the host
     * @param {number} port              Network port for the host to connect to
     * @param {TransportScheme} scheme   Transport scheme to use
     * @param {number} timeout           If no connection is established after `timeout` ms, the connection is terminated
     *
     * @throws {Error} if an incorrect transport scheme is specified
     */
    connect(host, port, scheme, timeout) {
        // Check that no existing socket exists before initiating a new connection.
        if (this.tcpSocket || this.webSocket) {
            throw (new Error('Cannot initiate a new socket connection when an existing connection exists'));
        }
        // Set a timer to force disconnect after `timeout` seconds
        this.timers.disconnect = setTimeout(() => this.disconnectOnTimeout(host, port, timeout), timeout);
        // Remove the timer if a connection is successfully established
        this.once('connect', this.clearDisconnectTimerOnTimeout);
        // Define how to refer to the connection scheme in debug output.
        const socketTypes = {
            [ElectrumTransport.TCP.Scheme]: 'a TCP Socket',
            [ElectrumTransport.TCP_TLS.Scheme]: 'an encrypted TCP socket',
            [ElectrumTransport.WS.Scheme]: 'a WebSocket',
            [ElectrumTransport.WSS.Scheme]: 'an encrypted WebSocket',
        };
        // Log that we are trying to establish a connection.
        debug.network(`Initiating ${socketTypes[scheme]} connection to '${host}:${port}'.`);
        if (scheme === ElectrumTransport.TCP.Scheme || scheme === ElectrumTransport.TCP_TLS.Scheme) {
            if (scheme === ElectrumTransport.TCP_TLS.Scheme) {
                // Initialize connection options.
                const connectionOptions = { rejectUnauthorized: false };
                // If the hostname is not an IP address..
                if (!net__default['default'].isIP(host)) {
                    // Set the servername option which enables support for SNI.
                    // NOTE: SNI enables a server that hosts multiple domains to provide the appropriate TLS certificate.
                    connectionOptions.serverName = host;
                }
                // Initialize this.tcpSocket (allowing self-signed certificates).
                this.tcpSocket = tls__default['default'].connect(port, host, connectionOptions);
                // Add a 'secureConnect' listener that checks the authorization status of
                // the socket, and logs a warning when it uses a self signed certificate.
                this.tcpSocket.once('secureConnect', () => {
                    // Cannot happen, since this event callback *only* exists on TLSSocket
                    if (!(this.tcpSocket instanceof tls__default['default'].TLSSocket))
                        return;
                    // Force cast authorizationError from Error to string (through unknown)
                    // because it is incorrectly typed as an Error
                    const authorizationError = this.tcpSocket.authorizationError;
                    if (authorizationError === 'DEPTH_ZERO_SELF_SIGNED_CERT') {
                        debug.warning(`Connection to ${host}:${port} uses a self-signed certificate`);
                    }
                });
                // Trigger successful connection events.
                this.tcpSocket.on('secureConnect', this.onConnect.bind(this, socketTypes[scheme], host, port));
            }
            else {
                // Initialize this.tcpSocket.
                this.tcpSocket = net__default['default'].connect({ host, port });
                // Trigger successful connection events.
                this.tcpSocket.on('connect', this.onConnect.bind(this, socketTypes[scheme], host, port));
            }
            // Configure encoding.
            this.tcpSocket.setEncoding('utf8');
            // Enable persistent connections with an initial delay of 0.
            this.tcpSocket.setKeepAlive(true, 0);
            // Disable buffering of outgoing data.
            this.tcpSocket.setNoDelay(true);
            // Forward the encountered errors.
            this.tcpSocket.on('error', this.eventForwarders.tcpError);
        }
        else if (scheme === ElectrumTransport.WS.Scheme || scheme === ElectrumTransport.WSS.Scheme) {
            if (scheme === ElectrumTransport.WSS.Scheme) {
                // Initialize this.webSocket (rejecting self-signed certificates).
                // We reject self-signed certificates to match functionality of browsers.
                this.webSocket = new WebSocket__default['default'](`wss://${host}:${port}`);
            }
            else {
                // Initialize this.webSocket.
                this.webSocket = new WebSocket__default['default'](`ws://${host}:${port}`);
            }
            // Trigger successful connection events.
            this.webSocket.addEventListener('open', this.onConnect.bind(this, socketTypes[scheme], host, port));
            // Forward the encountered errors.
            this.webSocket.addEventListener('error', this.eventForwarders.wsError);
        }
        else {
            // Throw an error if an incorrect transport is specified
            throw (new Error('Incorrect transport specified'));
        }
    }
    /**
     * Sets up forwarding of events related to the connection.
     *
     * @param {string} connectionType   Name of the connection/transport type, used for logging.
     * @param {string} host             Fully qualified domain name or IP address of the host
     * @param {number} port             Network port for the host to connect to
     */
    onConnect(connectionType, host, port) {
        // If the onConnect function has already run, do not execute it again.
        if (this.onConnectHasRun)
            return;
        // Log that the connection has been established.
        debug.network(`Established ${connectionType} connection with '${host}:${port}'.`);
        if (typeof this.tcpSocket !== 'undefined') {
            // Forward the socket events
            this.tcpSocket.addListener('close', this.eventForwarders.disconnect);
            this.tcpSocket.addListener('data', this.eventForwarders.tcpData);
        }
        else if (typeof this.webSocket !== 'undefined') {
            // Forward the socket events
            this.webSocket.addEventListener('close', this.eventForwarders.disconnect);
            this.webSocket.addEventListener('message', this.eventForwarders.wsData);
        }
        // Indicate that the onConnect function has run.
        this.onConnectHasRun = true;
        // Emit the connect event.
        this.emit('connect');
    }
    /**
     * Clears the disconnect timer if it is still active.
     */
    clearDisconnectTimerOnTimeout() {
        // Clear the retry timer if it is still active.
        if (this.timers.disconnect) {
            clearTimeout(this.timers.disconnect);
        }
    }
    /**
     * Forcibly terminate the connection.
     *
     * @throws {Error} if no connection was found
     */
    disconnect() {
        // Clear the disconnect timer so that the socket does not try to disconnect again later.
        this.clearDisconnectTimerOnTimeout();
        // Handle disconnect based differently depending on socket type.
        if (this.tcpSocket) {
            // Remove all event forwarders.
            this.tcpSocket.removeListener('close', this.eventForwarders.disconnect);
            this.tcpSocket.removeListener('data', this.eventForwarders.tcpData);
            this.tcpSocket.removeListener('error', this.eventForwarders.tcpError);
            // Terminate the connection.
            this.tcpSocket.destroy();
            // Remove the stored socket.
            this.tcpSocket = undefined;
        }
        else if (this.webSocket) {
            try {
                // Remove all event forwarders.
                this.webSocket.removeEventListener('close', this.eventForwarders.disconnect);
                this.webSocket.removeEventListener('message', this.eventForwarders.wsData);
                this.webSocket.removeEventListener('error', this.eventForwarders.wsError);
                // Gracefully terminate the connection.
                this.webSocket.close();
            }
            catch (ignored) {
                // close() will throw an error if the connection has not been established yet.
                // We ignore this error, since no similar error gets thrown in the TLS Socket.
            }
            finally {
                // Remove the stored socket regardless of any thrown errors.
                this.webSocket = undefined;
            }
        }
        // Indicate that the onConnect function has not run and it has to be run again.
        this.onConnectHasRun = false;
        // Emit a disconnect event
        this.emit('disconnect');
    }
    /**
     * Write data to the socket
     *
     * @param {Uint8Array | string} data   Data to be written to the socket
     * @param {function} callback          Callback function to be called when the write has completed
     *
     * @throws {Error} if no connection was found
     * @returns true if the message was fully flushed to the socket, false if part of the message
     * is queued in the user memory
     */
    write(data, callback) {
        if (this.tcpSocket) {
            // Write data to the TLS Socket and return the status indicating whether the
            // full message was flushed to the socket
            return this.tcpSocket.write(data, callback);
        }
        if (this.webSocket) {
            // Write data to the WebSocket
            this.webSocket.send(data, callback);
            // WebSockets always fit everything in a single request, so we return true
            return true;
        }
        // Throw an error if no active connection is found
        throw (new Error('Cannot write to socket when there is no active connection'));
    }
    /**
     * Force a disconnection if no connection is established after `timeout` milliseconds.
     *
     * @param {string} host      Host of the connection that timed out
     * @param {number} port      Port of the connection that timed out
     * @param {number} timeout   Elapsed milliseconds
     */
    disconnectOnTimeout(host, port, timeout) {
        // Remove the connect listener.
        this.removeListener('connect', this.clearDisconnectTimerOnTimeout);
        // Create a new timeout error.
        const timeoutError = { code: 'ETIMEDOUT', message: `Connection to '${host}:${port}' timed out after ${timeout} milliseconds` };
        // Emit an error event so that connect is rejected upstream.
        this.emit('error', timeoutError);
        // Forcibly disconnect to clean up the connection on timeout
        this.disconnect();
    }
}

/**
 * Wrapper around TLS/WSS sockets that gracefully separates a network stream into Electrum protocol messages.
 *
 * @ignore
 */
class ElectrumConnection extends events.EventEmitter {
    application;
    version;
    host;
    port;
    scheme;
    timeout;
    pingInterval;
    // Declare an empty socket.
    socket;
    // Declare empty timestamps
    lastReceivedTimestamp;
    // Declare timers for keep-alive pings and reconnection
    timers = {};
    // Initialize an empty array of connection verification timers.
    // eslint-disable-next-line no-undef
    verifications = [];
    // Initialize the connected flag to false to indicate that there is no connection
    status = exports.ConnectionStatus.DISCONNECTED;
    // Initialize messageBuffer to an empty string
    messageBuffer = '';
    /**
     * Sets up network configuration for an Electrum client connection.
     *
     * @param {string} application       your application name, used to identify to the electrum host.
     * @param {string} version           protocol version to use with the host.
     * @param {string} host              fully qualified domain name or IP number of the host.
     * @param {number} port              the network port of the host.
     * @param {TransportScheme} scheme   the transport scheme to use for connection
     * @param {number} timeout           how long network delays we will wait for before taking action, in milliseconds.
     * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.
     *
     * @throws {Error} if `version` is not a valid version string.
     */
    constructor(application, version, host, port = DefaultParameters.PORT, scheme = DefaultParameters.TRANSPORT_SCHEME, timeout = DefaultParameters.TIMEOUT, pingInterval = DefaultParameters.PING_INTERVAL) {
        // Initialize the event emitter.
        super();
        this.application = application;
        this.version = version;
        this.host = host;
        this.port = port;
        this.scheme = scheme;
        this.timeout = timeout;
        this.pingInterval = pingInterval;
        // Check if the provided version is a valid version number.
        if (!ElectrumProtocol.versionRegexp.test(version)) {
            // Throw an error since the version number was not valid.
            throw (new Error(`Provided version string (${version}) is not a valid protocol version number.`));
        }
        // Create an initial network socket.
        this.createSocket();
    }
    /**
     * Returns a string for the host identifier for usage in debug messages.
     */
    get hostIdentifier() {
        return `${this.host}:${this.port}`;
    }
    /**
     * Create and configures a fresh socket and attaches all relevant listeners.
     */
    createSocket() {
        // Initialize a new ElectrumSocket
        this.socket = new ElectrumSocket();
        // Set up handlers for connection and disconnection.
        this.socket.on('connect', this.onSocketConnect.bind(this));
        this.socket.on('disconnect', this.onSocketDisconnect.bind(this));
        // Set up handler for incoming data.
        this.socket.on('data', this.parseMessageChunk.bind(this));
    }
    /**
     * Shuts down and destroys the current socket.
     */
    destroySocket() {
        // Close the socket connection and destroy the socket.
        this.socket.disconnect();
    }
    /**
     * Assembles incoming data into statements and hands them off to the message parser.
     *
     * @param {string} data   data to append to the current message buffer, as a string.
     *
     * @throws {SyntaxError} if the passed statement parts are not valid JSON.
     */
    parseMessageChunk(data) {
        // Update the timestamp for when we last received data.
        this.lastReceivedTimestamp = Date.now();
        // Clear and remove all verification timers.
        this.verifications.forEach((timer) => clearTimeout(timer));
        this.verifications.length = 0;
        // Add the message to the current message buffer.
        this.messageBuffer += data;
        // Check if the new message buffer contains the statement delimiter.
        while (this.messageBuffer.includes(ElectrumProtocol.statementDelimiter)) {
            // Split message buffer into statements.
            const statementParts = this.messageBuffer.split(ElectrumProtocol.statementDelimiter);
            // For as long as we still have statements to parse..
            while (statementParts.length > 1) {
                // Move the first statement to its own variable.
                const currentStatementList = String(statementParts.shift());
                // Parse the statement into an object or list of objects.
                let statementList = JSON.parse(currentStatementList);
                // Wrap the statement in an array if it is not already a batched statement list.
                if (!Array.isArray(statementList)) {
                    statementList = [statementList];
                }
                // For as long as there is statements in the result set..
                while (statementList.length > 0) {
                    // Move the first statement from the batch to its own variable.
                    const currentStatement = statementList.shift();
                    // If the current statement is a version negotiation response..
                    if (currentStatement.id === 'versionNegotiation') {
                        if (currentStatement.error) {
                            // Then emit a failed version negotiation response signal.
                            this.emit('version', { error: currentStatement.error });
                        }
                        else {
                            // Emit a successful version negotiation response signal.
                            this.emit('version', { software: currentStatement.result[0], protocol: currentStatement.result[1] });
                        }
                        // Consider this statement handled.
                        continue;
                    }
                    // If the current statement is a keep-alive response..
                    if (currentStatement.id === 'keepAlive') {
                        // Do nothing and consider this statement handled.
                        continue;
                    }
                    // Emit the statements for handling higher up in the stack.
                    this.emit('statement', currentStatement);
                }
            }
            // Store the remaining statement as the current message buffer.
            this.messageBuffer = statementParts.shift() || '';
        }
    }
    /**
     * Sends a keep-alive message to the host.
     *
     * @returns true if the ping message was fully flushed to the socket, false if
     * part of the message is queued in the user memory
     */
    ping() {
        // Write a log message.
        debug.ping(`Sending keep-alive ping to '${this.hostIdentifier}'`);
        // Craft a keep-alive message.
        const message = ElectrumProtocol.buildRequestObject('server.ping', [], 'keepAlive');
        // Send the keep-alive message.
        const status = this.send(message);
        // Return the ping status.
        return status;
    }
    /**
     * Initiates the network connection negotiates a protocol version. Also emits the 'connect' signal if successful.
     *
     * @throws {Error} if the socket connection fails.
     * @returns a promise resolving when the connection is established
     */
    async connect() {
        // If we are already connected return true.
        if (this.status === exports.ConnectionStatus.CONNECTED) {
            return;
        }
        // Indicate that the connection is connecting
        this.status = exports.ConnectionStatus.CONNECTING;
        // Define a function to wrap connection as a promise.
        const connectionResolver = (resolve, reject) => {
            const rejector = (error) => {
                // Set the status back to disconnected
                this.status = exports.ConnectionStatus.DISCONNECTED;
                // Reject with the error as reason
                reject(error);
            };
            // Replace previous error handlers to reject the promise on failure.
            this.socket.removeAllListeners('error');
            this.socket.once('error', rejector);
            // Define a function to wrap version negotiation as a callback.
            const versionNegotiator = () => {
                // Write a log message to show that we have started version negotiation.
                debug.network(`Requesting protocol version ${this.version} with '${this.hostIdentifier}'.`);
                // remove the one-time error handler since no error was detected.
                this.socket.removeListener('error', rejector);
                // Build a version negotiation message.
                const versionMessage = ElectrumProtocol.buildRequestObject('server.version', [this.application, this.version], 'versionNegotiation');
                // Define a function to wrap version validation as a function.
                const versionValidator = (version) => {
                    // Check if version negotiation failed.
                    if (isVersionRejected(version)) {
                        // Disconnect from the host.
                        this.disconnect(true);
                        // Declare an error message.
                        const errorMessage = 'unsupported protocol version.';
                        // Log the error.
                        debug.errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);
                        // Reject the connection with false since version negotiation failed.
                        reject(errorMessage);
                    }
                    // Check if the host supports our requested protocol version.
                    else if (version.protocol !== this.version) {
                        // Disconnect from the host.
                        this.disconnect(true);
                        // Declare an error message.
                        const errorMessage = `incompatible protocol version negotiated (${version.protocol} !== ${this.version}).`;
                        // Log the error.
                        debug.errors(`Failed to connect with ${this.hostIdentifier} due to ${errorMessage}`);
                        // Reject the connection with false since version negotiation failed.
                        reject(errorMessage);
                    }
                    else {
                        // Write a log message.
                        debug.network(`Negotiated protocol version ${version.protocol} with '${this.hostIdentifier}', powered by ${version.software}.`);
                        // Set connection status to connected
                        this.status = exports.ConnectionStatus.CONNECTED;
                        // Emit a connect event now that the connection is usable.
                        this.emit('connect');
                        // Resolve the connection promise since we successfully connected and negotiated protocol version.
                        resolve();
                    }
                };
                // Listen for version negotiation once.
                this.once('version', versionValidator);
                // Send the version negotiation message.
                this.send(versionMessage);
            };
            // Prepare the version negotiation.
            this.socket.once('connect', versionNegotiator);
            // Set up handler for network errors.
            this.socket.on('error', this.onSocketError.bind(this));
            // Connect to the server.
            this.socket.connect(this.host, this.port, this.scheme, this.timeout);
        };
        // Wait until connection is established and version negotiation succeeds.
        await new Promise(connectionResolver);
    }
    /**
     * Restores the network connection.
     */
    async reconnect() {
        // If a reconnect timer is set, remove it
        await this.clearReconnectTimer();
        // Write a log message.
        debug.network(`Trying to reconnect to '${this.hostIdentifier}'..`);
        // Set the status to reconnecting for more accurate log messages.
        this.status = exports.ConnectionStatus.RECONNECTING;
        // Destroy and recreate the socket to get a clean slate.
        this.destroySocket();
        this.createSocket();
        try {
            // Try to connect again.
            await this.connect();
        }
        catch (error) {
            // Do nothing as the error should be handled via the disconnect and error signals.
        }
    }
    /**
     * Removes the current reconnect timer.
     */
    clearReconnectTimer() {
        // If a reconnect timer is set, remove it
        if (this.timers.reconnect) {
            clearTimeout(this.timers.reconnect);
        }
        // Reset the timer reference.
        this.timers.reconnect = undefined;
    }
    /**
     * Removes the current keep-alive timer.
     */
    clearKeepAliveTimer() {
        // If a keep-alive timer is set, remove it
        if (this.timers.keepAlive) {
            clearTimeout(this.timers.keepAlive);
        }
        // Reset the timer reference.
        this.timers.keepAlive = undefined;
    }
    /**
     * Initializes the keep alive timer loop.
     */
    setupKeepAliveTimer() {
        // If the keep-alive timer loop is not currently set up..
        if (!this.timers.keepAlive) {
            // Set a new keep-alive timer.
            this.timers.keepAlive = setTimeout(this.ping.bind(this), this.pingInterval);
        }
    }
    /**
     * Tears down the current connection and removes all event listeners on disconnect.
     *
     * @param {boolean} force   disconnect even if the connection has not been fully established yet.
     *
     * @returns true if successfully disconnected, or false if there was no connection.
     */
    async disconnect(force = false) {
        // Return early when there is nothing to disconnect from
        if (this.status === exports.ConnectionStatus.DISCONNECTED && !force) {
            // Return false to indicate that there was nothing to disconnect from.
            return false;
        }
        // Set connection status to null to indicate tear-down is currently happening.
        this.status = exports.ConnectionStatus.DISCONNECTING;
        // If a keep-alive timer is set, remove it.
        await this.clearKeepAliveTimer();
        // If a reconnect timer is set, remove it
        await this.clearReconnectTimer();
        const disconnectResolver = (resolve) => {
            // Resolve to true after the connection emits a disconnect
            this.once('disconnect', () => resolve(true));
            // Close the connection and destroy the socket.
            this.destroySocket();
        };
        // Return true to indicate that we disconnected.
        return new Promise(disconnectResolver);
    }
    /**
     * Sends an arbitrary message to the server.
     *
     * @param {string} message   json encoded request object to send to the server, as a string.
     *
     * @returns true if the message was fully flushed to the socket, false if part of the message
     * is queued in the user memory
     */
    send(message) {
        // Remove the current keep-alive timer if it exists.
        this.clearKeepAliveTimer();
        // Get the current timestamp in milliseconds.
        const currentTime = Date.now();
        // Follow up and verify that the message got sent..
        const verificationTimer = setTimeout(this.verifySend.bind(this, currentTime), this.timeout);
        // Store the verification timer locally so that it can be cleared when data has been received.
        this.verifications.push(verificationTimer);
        // Set a new keep-alive timer.
        this.setupKeepAliveTimer();
        // Write the message to the network socket.
        return this.socket.write(message + ElectrumProtocol.statementDelimiter);
    }
    // --- Event managers. --- //
    /**
     * Marks the connection as timed out and schedules reconnection if we have not
     * received data within the expected time frame.
     */
    verifySend(sentTimestamp) {
        // If we haven't received any data since we last sent data out..
        if (Number(this.lastReceivedTimestamp) < sentTimestamp) {
            // If this connection is already disconnected, we do not change anything
            if ((this.status === exports.ConnectionStatus.DISCONNECTED) || (this.status === exports.ConnectionStatus.DISCONNECTING)) {
                debug.errors(`Tried to verify already disconnected connection to '${this.hostIdentifier}'`);
                return;
            }
            // Remove the current keep-alive timer if it exists.
            this.clearKeepAliveTimer();
            // Write a notification to the logs.
            debug.network(`Connection to '${this.hostIdentifier}' timed out.`);
            // Close the connection to avoid re-use.
            // NOTE: This initiates reconnection routines if the connection has not
            //       been marked as intentionally disconnected.
            this.socket.disconnect();
        }
    }
    /**
     * Updates the connection status when a connection is confirmed.
     */
    onSocketConnect() {
        // If a reconnect timer is set, remove it.
        this.clearReconnectTimer();
        // Set up the initial timestamp for when we last received data from the server.
        this.lastReceivedTimestamp = Date.now();
        // Set up the initial keep-alive timer.
        this.setupKeepAliveTimer();
        // Clear all temporary error listeners.
        this.socket.removeAllListeners('error');
        // Set up handler for network errors.
        this.socket.on('error', this.onSocketError.bind(this));
    }
    /**
     * Updates the connection status when a connection is ended.
     */
    onSocketDisconnect() {
        // Send a disconnect signal higher up the stack.
        this.emit('disconnect');
        // Remove the current keep-alive timer if it exists.
        this.clearKeepAliveTimer();
        // If this is a connection we're trying to tear down..
        if (this.status === exports.ConnectionStatus.DISCONNECTING) {
            // If a reconnect timer is set, remove it.
            this.clearReconnectTimer();
            // Remove all event listeners
            this.removeAllListeners();
            // Mark the connection as disconnected.
            this.status = exports.ConnectionStatus.DISCONNECTED;
            // Write a log message.
            debug.network(`Disconnected from '${this.hostIdentifier}'.`);
        }
        else {
            // If this is for an established connection..
            if (this.status === exports.ConnectionStatus.CONNECTED) {
                // Write a notification to the logs.
                debug.errors(`Connection with '${this.hostIdentifier}' was closed, trying to reconnect in ${DefaultParameters.RECONNECT / 1000} seconds.`);
            }
            // Mark the connection as disconnected for now..
            this.status = exports.ConnectionStatus.DISCONNECTED;
            // If we don't have a pending reconnection timer..
            if (!this.timers.reconnect) {
                // Attempt to reconnect after one keep-alive duration.
                this.timers.reconnect = setTimeout(this.reconnect.bind(this), DefaultParameters.RECONNECT);
            }
        }
    }
    /**
     * Notify administrator of any unexpected errors.
     */
    onSocketError(error) {
        // Report a generic error if no error information is present.
        // NOTE: When using WSS, the error event explicitly
        //       only allows to send a "simple" event without data.
        //       https://stackoverflow.com/a/18804298
        if (typeof error === 'undefined') {
            // Do nothing, and instead rely on the socket disconnect event for further information.
            return;
        }
        // If the DNS lookup failed.
        if (error.code === 'EAI_AGAIN') {
            debug.errors(`Failed to look up DNS records for '${this.host}'.`);
            return;
        }
        // If the connection timed out..
        if (error.code === 'ETIMEDOUT') {
            // Log the provided timeout message.
            debug.errors(error.message);
            return;
        }
        // Log unknown error
        debug.errors(`Unknown network error ('${this.hostIdentifier}'): `, error);
    }
}

const isRPCErrorResponse = function (message) {
    return 'id' in message && 'error' in message;
};
const isRPCNotification = function (message) {
    return !('id' in message) && 'method' in message;
};

/**
 * Triggers when the underlying connection is established.
 *
 * @event ElectrumClient#connected
 */
/**
 * Triggers when the underlying connection is lost.
 *
 * @event ElectrumClient#disconnected
 */
/**
 * High-level Electrum client that lets applications send requests and subscribe to notification events from a server.
 */
class ElectrumClient extends events.EventEmitter {
    // Declare instance variables
    connection;
    // Initialize an empty list of subscription metadata.
    subscriptionMethods = {};
    subscriptionCallbacks = new WeakMap();
    // Start counting the request IDs from 0
    requestId = 0;
    // Initialize an empty dictionary for keeping track of request resolvers
    requestResolvers = {};
    /**
     * Initializes an Electrum client.
     *
     * @param {string} application       your application name, used to identify to the electrum host.
     * @param {string} version           protocol version to use with the host.
     * @param {string} host              fully qualified domain name or IP number of the host.
     * @param {number} port              the TCP network port of the host.
     * @param {TransportScheme} scheme   the transport scheme to use for connection
     * @param {number} timeout           how long network delays we will wait for before taking action, in milliseconds.
     * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.
     *
     * @throws {Error} if `version` is not a valid version string.
     */
    constructor(application, version, host, port = DefaultParameters.PORT, scheme = DefaultParameters.TRANSPORT_SCHEME, timeout = DefaultParameters.TIMEOUT, pingInterval = DefaultParameters.PING_INTERVAL) {
        // Initialize the event emitter.
        super();
        // Set up a connection to an electrum server.
        this.connection = new ElectrumConnection(application, version, host, port, scheme, timeout, pingInterval);
    }
    /**
     * Connects to the remote server.
     *
     * @throws {Error} if the socket connection fails.
     * @returns a promise resolving when the connection is established.
     */
    async connect() {
        // Listen for parsed statements.
        this.connection.on('statement', this.response.bind(this));
        // Hook up resubscription on connection.
        this.connection.on('connect', this.resubscribeOnConnect.bind(this));
        // Relay connect and disconnect events.
        this.connection.on('connect', this.emit.bind(this, 'connected'));
        this.connection.on('disconnect', this.onConnectionDisconnect.bind(this));
        // Relay error events.
        this.connection.on('error', this.emit.bind(this, 'error'));
        // Connect with the server.
        await this.connection.connect();
    }
    /**
     * Disconnects from the remote server and removes all event listeners/subscriptions and open requests.
     *
     * @param {boolean} force                 disconnect even if the connection has not been fully established yet.
     * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.
     *
     * @returns true if successfully disconnected, or false if there was no connection.
     */
    async disconnect(force = false, retainSubscriptions = false) {
        if (!retainSubscriptions) {
            // Cancel all event listeners.
            this.removeAllListeners();
            // Remove all subscription data
            this.subscriptionMethods = {};
        }
        // For each pending request..
        for (const index in this.requestResolvers) {
            // Reject the request.
            const requestResolver = this.requestResolvers[index];
            requestResolver(new Error('Manual disconnection'));
            // Remove the request.
            delete this.requestResolvers[index];
        }
        // Disconnect from the remove server.
        return this.connection.disconnect(force);
    }
    /**
     * Calls a method on the remote server with the supplied parameters.
     *
     * @param {string} method          name of the method to call.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if the client is disconnected.
     * @returns a promise that resolves with the result of the method or an Error.
     */
    async request(method, ...parameters) {
        // If we are not connected to a server..
        if (this.connection.status !== exports.ConnectionStatus.CONNECTED) {
            // Reject the request with a disconnected error message.
            throw (new Error(`Unable to send request to a disconnected server '${this.connection.host}'.`));
        }
        // Increase the request ID by one.
        this.requestId += 1;
        // Store a copy of the request id.
        const id = this.requestId;
        // Format the arguments as an electrum request object.
        const message = ElectrumProtocol.buildRequestObject(method, parameters, id);
        // Define a function to wrap the request in a promise.
        const requestResolver = (resolve) => {
            // Add a request resolver for this promise to the list of requests.
            this.requestResolvers[id] = (error, data) => {
                // If the resolution failed..
                if (error) {
                    // Resolve the promise with the error for the application to handle.
                    resolve(error);
                }
                else {
                    // Resolve the promise with the request results.
                    resolve(data);
                }
            };
            // Send the request message to the remote server.
            this.connection.send(message);
        };
        // Write a log message.
        debug.network(`Sending request '${method}' to '${this.connection.host}'`);
        // return a promise to deliver results later.
        return new Promise(requestResolver);
    }
    /**
     * Subscribes to the method at the server and attaches the callback function to the event feed.
     *
     * @param {function}  callback     a function that should get notification messages.
     * @param {string}    method       one of the subscribable methods the server supports.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if the client is disconnected.
     * @returns a promise resolving to true when the subscription is set up.
     */
    async subscribe(callback, method, ...parameters) {
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // If this method is not yet being listened on with this callback..
            if (!this.listeners(method).includes(callback)) {
                // Set up event listener for this subscription.
                this.addListener(method, callback);
            }
            // If this method has never been subscribed to before..
            if (!this.subscriptionMethods[method]) {
                // Initialize an empty subscription payload list for this method.
                this.subscriptionMethods[method] = [];
            }
            // Store the subscription parameters to track what data we have subscribed to.
            this.subscriptionMethods[method].push(JSON.stringify(parameters));
            // Get the currently subscribed payloads for this callback, or an empty array if none exist.
            const subscriptionCallbackPayloads = this.subscriptionCallbacks.get(callback) || [];
            // Update the subscription parameters to track what data this callback is listening on.
            subscriptionCallbackPayloads.push({ method, payload: JSON.stringify(parameters) });
            // Store the subscription parameters.
            this.subscriptionCallbacks.set(callback, subscriptionCallbackPayloads);
            // Send initial subscription request.
            const requestData = await this.request(method, ...parameters);
            // Manually send the initial request data to the callback.
            callback(requestData);
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is set up.
        return new Promise(subscriptionResolver);
    }
    /**
     * Unsubscribes to the method at the server and removes any callback functions
     * when there are no more subscriptions for the method.
     *
     * @param {function}  callback     a function that has previously been subscribed for this method.
     * @param {string}    method       a previously subscribed to method.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if no subscriptions exist for the combination of the passed `callback`, `method` and `parameters.
     * @throws {Error} if the client is disconnected.
     * @returns a promise that resolves to true when the subscription has been cancelled.
     */
    async unsubscribe(callback, method, ...parameters) {
        // Throw an error if the client is disconnected.
        if (this.connection.status !== exports.ConnectionStatus.CONNECTED) {
            throw (new Error(`Unable to send unsubscribe request to a disconnected server '${this.connection.host}'.`));
        }
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // Pack up the parameters as a long string.
            const subscriptionParameters = JSON.stringify(parameters);
            // If this method has no subscriptions..
            if (!this.subscriptionMethods[method]) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe from '${method}' since the method has no subscriptions.`));
            }
            // If this callback has no subscriptions..
            if (!this.subscriptionCallbacks.has(callback)) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe with '${callback.name}' since the callback has no subscriptions.`));
            }
            // Count the number of methods subscribed to this payload.
            const serverMethodPayloadCount = Object.values(this.subscriptionMethods[method])
                .filter((payload) => payload === subscriptionParameters).length;
            // Count the number of callbacks attached to this method.
            const callbackMethodPayloadCount = (this.subscriptionCallbacks.get(callback) || [])
                .filter((value) => value.method === method).length;
            // Locate the method and callback subscription index.
            const serverMethodPayloadIndex = this.subscriptionMethods[method].indexOf(subscriptionParameters);
            const callbackMethodPayloadIndex = (this.subscriptionCallbacks.get(callback) || [])
                .findIndex((value) => (value.method === method && value.payload === subscriptionParameters));
            // If the method payload could not be located..
            if (serverMethodPayloadIndex < 0) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe from '${method}' since it has no subscription with the given parameters.`));
            }
            // If the callback payload could not be located..
            if (callbackMethodPayloadIndex < 0) {
                // Reject this promise with an explanation.
                throw (new Error(`Cannot unsubscribe with '${callback.name}' since it has no subscription with the given method and parameters.`));
            }
            // If this is the last payload that any callback has for this method..
            if (serverMethodPayloadCount === 1) {
                // Remove this specific subscription payload from internal tracking.
                this.subscriptionMethods[method].splice(serverMethodPayloadIndex, 1);
                // If the subscription conforms to expected naming standards..
                if (method.endsWith('.subscribe')) {
                    // Send unsubscription request to the server.
                    await this.request(method.replace('.subscribe', '.unsubscribe'), ...parameters);
                }
            }
            // If this is the last payload that this specific callback has to this method..
            if (callbackMethodPayloadCount === 1) {
                // Remove the current callback from listening to given method.
                this.removeListener(method, callback);
            }
            // Get the currently subscribed payloads for this callback, or an empty array if none exist.
            const subscriptionCallbackPayloads = this.subscriptionCallbacks.get(callback) || [];
            // Remove the internal tracking of this callbacks specific method and payload combination.
            this.subscriptionCallbacks.set(callback, subscriptionCallbackPayloads.splice(callbackMethodPayloadIndex, 1));
            // Write a log message.
            debug.client(`Unsubscribed callback '${callback.name}' from '${String(method)}' for the '${subscriptionParameters}' parameters.`);
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is torn down.
        return new Promise(subscriptionResolver);
    }
    /**
     * Restores existing subscriptions without updating status or triggering manual callbacks.
     *
     * @throws {Error} if subscription data cannot be found for all stored event names.
     * @throws {Error} if the client is disconnected.
     * @returns a promise resolving to true when the subscriptions are restored.
     *
     * @ignore
     */
    async resubscribeOnConnect() {
        // Write a log message.
        debug.client(`Connected to '${this.connection.hostIdentifier}'.`);
        // For each method we have a listener for..
        for (const method of this.eventNames()) {
            // Ignore the connected, disconnected and error method/signals..
            if (method === 'connected' || method === 'disconnected' || method === 'error') {
                continue;
            }
            // Check that we really have a subscription to restore.
            if (!this.subscriptionMethods[String(method)]) {
                // Throw an error since this breaks our expectations.
                throw (new Error(`Unable to resubscribe to ${String(method)} at ${this.connection.hostIdentifier} due to missing subscription data.`));
            }
            // .. and for each parameter we have previously been subscribed to..
            for (const parameterJSON of this.subscriptionMethods[String(method)]) {
                // restore the parameters from JSON.
                const parameters = JSON.parse(parameterJSON);
                // Send a subscription request.
                await this.request(String(method), ...parameters);
            }
            // Write a log message.
            debug.client(`Restored ${this.subscriptionMethods[String(method)].length} previous '${String(method)}' subscriptions for '${this.connection.hostIdentifier}'`);
        }
        // Resolve the subscription promise.
        return true;
    }
    /**
     * Parser messages from the remote server to resolve request promises and emit subscription events.
     *
     * @param {RPCNotification | RPCResponse} message   the response message
     *
     * @throws {Error} if the message ID does not match an existing request.
     * @ignore
     */
    response(message) {
        // If the received message is a notification, we forward it to all event listeners
        if (isRPCNotification(message)) {
            // Write a log message.
            debug.client(`Received notification for '${message.method}' from '${this.connection.host}'`);
            // Forward the message content to all event listeners.
            this.emit(message.method, message.params);
            // Return since it does not have an associated request resolver
            return;
        }
        // If the response ID is null we cannot use it to index our request resolvers
        if (message.id === null) {
            // Throw an internal error, this should not happen.
            throw (new Error('Internal error: Received an RPC response with ID null.'));
        }
        // Look up which request promise we should resolve this.
        const requestResolver = this.requestResolvers[message.id];
        // If we do not have a request resolver for this response message..
        if (!requestResolver) {
            // Throw an internal error, this should not happen.
            throw (new Error('Internal error: Callback for response not available.'));
        }
        // Remove the promise from the request list.
        delete this.requestResolvers[message.id];
        // If the message contains an error..
        if (isRPCErrorResponse(message)) {
            // Forward the message error to the request resolver and omit the `result` parameter.
            requestResolver(new Error(message.error.message));
        }
        else {
            // Forward the message content to the request resolver and omit the `error` parameter
            // (by setting it to undefined).
            requestResolver(undefined, message.result);
        }
    }
    /**
     * Callback function that is called when connection to the Electrum server is lost.
     * Aborts all active requests with an error message indicating that connection was lost.
     *
     * @ignore
     */
    onConnectionDisconnect() {
        // Emit a disconnection signal to any listeners.
        this.emit('disconnected');
        // Loop over active requests
        for (const resolverId in this.requestResolvers) {
            // Extract request resolver for readability
            const requestResolver = this.requestResolvers[resolverId];
            // Resolve the active request with an error indicating that the connection was lost.
            requestResolver(new Error('Connection lost'));
            // Remove the promise from the request list.
            delete this.requestResolvers[resolverId];
        }
    }
}

/**
 * Triggers when the cluster connects to enough servers to satisfy both the cluster confidence and distribution policies.
 *
 * @event ElectrumCluster#ready
 */
/**
 * Triggers when the cluster loses a connection and can no longer satisfy the cluster distribution policy.
 *
 * @event ElectrumCluster#degraded
 */
/**
 * Triggers when the cluster loses a connection and can no longer satisfy the cluster confidence policy.
 *
 * @event ElectrumCluster#disabled
 */
/**
 * High-level electrum client that provides transparent load balancing, confidence checking and/or low-latency polling.
 */
class ElectrumCluster extends events.EventEmitter {
    application;
    version;
    timeout;
    pingInterval;
    // Declare instance variables
    strategy;
    // Initialize an empty dictionary of clients in the cluster
    clients = {};
    // Start at 0 connected clients
    connections = 0;
    // Set up an empty set of notification data.
    notifications = {};
    // Start the cluster in DISABLED state
    status = exports.ClusterStatus.DISABLED;
    // Start counting request IDs at 0
    requestCounter = 0;
    // Initialize an empty dictionary for keeping track of request resolvers
    requestPromises = {};
    // Lock to prevent concurrency race conditions when sending requests.
    requestLock = new asyncMutex.Mutex();
    // Lock to prevent concurrency race conditions when receiving responses.
    responseLock = new asyncMutex.Mutex();
    /**
     * @param {string} application    your application name, used to identify to the electrum hosts.
     * @param {string} version        protocol version to use with the hosts.
     * @param {number} confidence     wait for this number of hosts to provide identical results.
     * @param {number} distribution   request information from this number of hosts.
     * @param {ClusterOrder} order    select hosts to communicate with in this order.
     * @param {number} timeout        how long network delays we will wait for before taking action, in milliseconds.
     * @param {number} pingInterval      the time between sending pings to the electrum host, in milliseconds.
     */
    constructor(application, version, confidence = DefaultParameters.CLUSTER_CONFIDENCE, distribution = DefaultParameters.CLUSTER_DISTRIBUTION, order = DefaultParameters.CLUSTER_ORDER, timeout = DefaultParameters.TIMEOUT, pingInterval = DefaultParameters.PING_INTERVAL) {
        // Initialize the event emitter.
        super();
        this.application = application;
        this.version = version;
        this.timeout = timeout;
        this.pingInterval = pingInterval;
        // Initialize strategy.
        this.strategy =
            {
                distribution: distribution,
                confidence: confidence,
                order: order,
            };
        // Write a log message.
        debug.cluster(`Initialized empty cluster (${confidence} of ${distribution || 'ALL'})`);
        // Print out a warning if we cannot guarantee consensus for subscription notifications.
        // Case 1: we don't know how many servers will be used, so warning just to be safe
        // Case 2: we know the number of servers needed to trust a response is less than 50%.
        if ((distribution === exports.ClusterDistribution.ALL) || (confidence / distribution <= 0.50)) {
            debug.warning(`Subscriptions might return multiple valid responses when confidence (${confidence}) is less than 51% of distribution.`);
        }
    }
    /**
     * Adds a server to the cluster.
     *
     * @param {string} host              fully qualified domain name or IP number of the host.
     * @param {number} port              the TCP network port of the host.
     * @param {TransportScheme} scheme   the transport scheme to use for connection
     * @param {boolean} autoConnect      flag indicating whether the server should automatically connect (default true)
     *
     * @throws {Error} if the cluster's version is not a valid version string.
     * @returns a promise that resolves when the connection has been initiated.
     */
    async addServer(host, port = DefaultParameters.PORT, scheme = DefaultParameters.TRANSPORT_SCHEME, autoConnect = true) {
        // Set up a new electrum client.
        const client = new ElectrumClient(this.application, this.version, host, port, scheme, this.timeout, this.pingInterval);
        // Store this client.
        this.clients[`${host}:${port}`] =
            {
                state: exports.ClientState.UNAVAILABLE,
                connection: client,
            };
        /**
         * Define a helper function to evaluate and log cluster status.
         *
         * @fires ElectrumCluster#ready
         * @fires ElectrumCluster#degraded
         * @fires ElectrumCluster#disabled
         */
        const updateClusterStatus = () => {
            // Calculate the required distribution, taking into account that distribution to all is represented with 0.
            const distribution = Math.max(this.strategy.confidence, this.strategy.distribution);
            // Check if we have enough connections to saturate distribution.
            if (this.connections >= distribution) {
                // If the cluster is not currently considered ready..
                if (this.status !== exports.ClusterStatus.READY) {
                    // Mark the cluster as ready.
                    this.status = exports.ClusterStatus.READY;
                    // Emit the ready signal to indicate the cluster is running in a ready mode.
                    this.emit('ready');
                    // Write a log message with an update on the current cluster status.
                    debug.cluster(`Cluster status is ready (currently ${this.connections} of ${distribution} connections available.)`);
                }
            }
            // If we still have enough available connections to reach confidence..
            else if (this.connections >= this.strategy.confidence) {
                // If the cluster is not currently considered degraded..
                if (this.status !== exports.ClusterStatus.DEGRADED) {
                    // Mark the cluster as degraded.
                    this.status = exports.ClusterStatus.DEGRADED;
                    // Emit the degraded signal to indicate the cluster is running in a degraded mode.
                    this.emit('degraded');
                    // Write a log message with an update on the current cluster status.
                    debug.cluster(`Cluster status is degraded (only ${this.connections} of ${distribution} connections available.)`);
                }
            }
            // If we don't have enough connections to reach confidence..
            // .. and the cluster is not currently considered disabled..
            else if (this.status !== exports.ClusterStatus.DISABLED) {
                // Mark the cluster as disabled.
                this.status = exports.ClusterStatus.DISABLED;
                // Emit the degraded signal to indicate the cluster is disabled.
                this.emit('disabled');
                // Write a log message with an update on the current cluster status.
                debug.cluster(`Cluster status is disabled (only ${this.connections} of the ${distribution} connections are available.)`);
            }
        };
        // Define a function to run when client has connects.
        const onConnect = async () => {
            // Wrap in a try-catch so we can ignore errors.
            try {
                // Check connection status
                const connectionStatus = client.connection.status;
                // If the connection is fine..
                if (connectionStatus === exports.ConnectionStatus.CONNECTED) {
                    // If this was from an unavailable connection..
                    if (this.clients[`${host}:${port}`].state === exports.ClientState.UNAVAILABLE) {
                        // Update connection counter.
                        this.connections += 1;
                    }
                    // Set client state to available.
                    this.clients[`${host}:${port}`].state = exports.ClientState.AVAILABLE;
                    // update the cluster status.
                    updateClusterStatus();
                }
            }
            catch (error) {
                // Do nothing.
            }
        };
        // Define a function to run when client disconnects.
        const onDisconnect = () => {
            // If this was from an established connection..
            if (this.clients[`${host}:${port}`].state === exports.ClientState.AVAILABLE) {
                // Update connection counter.
                this.connections -= 1;
            }
            // Set client state to unavailable.
            this.clients[`${host}:${port}`].state = exports.ClientState.UNAVAILABLE;
            // update the cluster status.
            updateClusterStatus();
        };
        // Set up handlers for connection and disconnection.
        client.connection.on('connect', onConnect.bind(this));
        client.connection.on('disconnect', onDisconnect.bind(this));
        // Connect if auto-connect is set to true, returning the connection result.
        if (autoConnect) {
            // Set up the connection.
            await client.connect();
        }
    }
    /**
     * Calls a method on the remote server with the supplied parameters.
     *
     * @param {string}    method       name of the method to call.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if not enough clients are connected
     * @throws {Error} if no response is received with sufficient integrity
     * @returns a promise that resolves with the result of the method.
     */
    async request(method, ...parameters) {
        // Check if the cluster is unable to serve requests.
        if (this.status === exports.ClusterStatus.DISABLED) {
            throw (new Error(`Cannot request '${method}' when available clients (${this.connections}) is less than required confidence (${this.strategy.confidence}).`));
        }
        // Lock this request method temporarily.
        const unlock = await this.requestLock.acquire();
        // Declare requestId outside of try-catch scope.
        let requestId = 0;
        // NOTE: If this async method is called very rapidly, it's theoretically possible that the parts below could interfere.
        try {
            // Increase the current request counter.
            this.requestCounter += 1;
            // Copy the request counter so we can work with the copy and know it won't change
            // even if the request counter is raised from concurrent requests.
            requestId = this.requestCounter;
        }
        finally {
            // Unlock this request method now that the concurrency sensitive condition is completed.
            unlock();
        }
        // Initialize an empty list of request promises.
        this.requestPromises[requestId] = [];
        // Extract all available client IDs
        const availableClientIDs = Object.keys(this.clients)
            .filter((clientID) => this.clients[clientID].state === exports.ClientState.AVAILABLE);
        // Initialize a sent counter.
        let sentCounter = 0;
        // Determine the number of clients we need to send to, taking ClusterDistribution.ALL (=0) into account.
        let requiredDistribution = (this.strategy.distribution || availableClientIDs.length);
        // If the cluster is in degraded status, we do not have enough available clients to
        // match distribution, but still enough to reach consensus, so we use the clients we have.
        if (this.status === exports.ClusterStatus.DEGRADED) {
            requiredDistribution = availableClientIDs.length;
        }
        // Repeat until we have sent the request to the desired number of clients.
        while (sentCounter < requiredDistribution) {
            // Pick an array index according to our ordering strategy.
            let currentIndex = 0;
            // Use a random array index when cluster order is set to RANDOM
            if (this.strategy.order === exports.ClusterOrder.RANDOM) {
                currentIndex = Math.floor(Math.random() * availableClientIDs.length);
            }
            // Move a client identity from the client list to its own variable.
            const [currentClient] = availableClientIDs.splice(currentIndex, 1);
            // Send the request to the client and store the request promise.
            const requestPromise = this.clients[currentClient].connection.request(method, ...parameters);
            this.requestPromises[requestId].push(requestPromise);
            // Increase the sent counter.
            sentCounter += 1;
        }
        // Define a function to poll for request responses.
        const pollResponse = (resolve, reject) => {
            // Define a function to resolve request responses based on integrity.
            const resolveRequest = async () => {
                // Set up an empty set of response data.
                const responseData = {};
                // Set up a counter to keep track of how many responses we have checked.
                let checkedResponses = 0;
                // For each server we issued a request to..
                for (const currentPromise in this.requestPromises[requestId]) {
                    // Race the request promise against a pre-resolved request to determine promise status.
                    const promises = [this.requestPromises[requestId][currentPromise], Promise.resolve(undefined)];
                    const response = await Promise.race(promises);
                    // If the promise is settled..
                    if (response !== undefined) {
                        // Calculate a unique identifier for this notification data.
                        const responseDataIdentifier = JSON.stringify(response);
                        // Increase the counter for checked responses.
                        checkedResponses += 1;
                        // Either set the response data counter or increase it.
                        if (responseData[responseDataIdentifier] === undefined) {
                            responseData[responseDataIdentifier] = 1;
                        }
                        else {
                            responseData[responseDataIdentifier] += 1;
                        }
                        // Check if this response has enough integrity according to our confidence strategy.
                        if (responseData[responseDataIdentifier] === this.strategy.confidence) {
                            // Write log entry.
                            debug.cluster(`Validated response for '${method}' with sufficient integrity (${this.strategy.confidence}).`);
                            // Resolve the request with this response.
                            resolve(response);
                            // Return after resolving since we do not want to continue the execution.
                            return;
                        }
                    }
                }
                // If all clients have responded but we failed to reach desired integrity..
                if (checkedResponses === this.requestPromises[requestId].length) {
                    // Reject this request with an error message.
                    reject(new Error(`Unable to complete request for '${method}', response failed to reach sufficient integrity (${this.strategy.confidence}).`));
                    // Return after rejecting since we do not want to continue the execution.
                    return;
                }
                // If we are not ready, but have not timed out and should wait more..
                setTimeout(resolveRequest, 1000);
            };
            // Attempt the initial resolution of the request.
            resolveRequest();
        };
        // return some kind of promise that resolves when integrity number of clients results match.
        return new Promise(pollResponse);
    }
    /**
     * Subscribes to the method at the cluster and attaches the callback function to the event feed.
     *
     * @param {function}  callback     a function that should get notification messages.
     * @param {string}    method       one of the subscribable methods the server supports.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if not enough clients are connected
     * @throws {Error} if no response is received with sufficient integrity for the initial request
     * @returns a promise resolving to true when the subscription is set up.
     */
    async subscribe(callback, method, ...parameters) {
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // Define a callback function to validate server notifications and pass
            // them to the subscribe callback.
            const subscriptionResponder = async (data) => {
                // Lock this response method temporarily.
                const unlock = await this.responseLock.acquire();
                try {
                    // Calculate a unique identifier for this notification data.
                    const responseDataIdentifier = JSON.stringify(data);
                    // Either set the notification counter or increase it.
                    if (this.notifications[responseDataIdentifier] === undefined) {
                        this.notifications[responseDataIdentifier] = 1;
                    }
                    else {
                        this.notifications[responseDataIdentifier] += 1;
                    }
                    // Check if this notification has enough integrity according to our confidence strategy.
                    if (this.notifications[responseDataIdentifier] === this.strategy.confidence) {
                        // Write log entry.
                        debug.cluster(`Validated notification for '${method}' with sufficient integrity (${this.strategy.confidence}).`);
                        // Send the notification data to the callback function.
                        callback(data);
                    }
                }
                finally {
                    // Unlock the response method so it can handle the next set of data.
                    unlock();
                }
            };
            // Set up event listener for this subscription.
            for (const currentClient in this.clients) {
                // Copy the current client for brevity.
                const client = this.clients[currentClient].connection;
                // If this method is not yet being listened on..
                if (!client.listeners(method).includes(subscriptionResponder)) {
                    // Set up event listener for this subscription.
                    client.addListener(method, subscriptionResponder);
                }
                // If this method has never been subscribed to before..
                if (!client.subscriptionMethods[method]) {
                    // Initialize an empty subscription payload list for this method.
                    client.subscriptionMethods[method] = [];
                }
                // Store the subscription parameters to track what data we have subscribed to.
                client.subscriptionMethods[method].push(JSON.stringify(parameters));
                // Get the currently subscribed payloads for this callback, or an empty array if none exist.
                const subscriptionCallbackPayloads = client.subscriptionCallbacks.get(callback) || [];
                // Update the subscription parameters to track what data this callback is listening on.
                subscriptionCallbackPayloads.push({ method, payload: JSON.stringify(parameters) });
                // Store the subscription parameters.
                client.subscriptionCallbacks.set(callback, subscriptionCallbackPayloads);
            }
            // Send initial subscription request.
            const requestData = await this.request(method, ...parameters);
            // Manually send the initial request data to the callback.
            callback(requestData);
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is set up.
        return new Promise(subscriptionResolver);
    }
    /**
     * Unsubscribes to the method at the cluster and removes any callback functions
     * when there are no more subscriptions for the method.
     *
     * @param {function}  callback     a function that has previously been subscribed for this method.
     * @param {string}    method       one of the subscribable methods the server supports.
     * @param {...string} parameters   one or more parameters for the method.
     *
     * @throws {Error} if, for any of the clients, no subscriptions exist for the combination of the
     * passed `callback`, `method` and `parameters.
     * @returns a promise resolving to true when the subscription has been cancelled.
     */
    async unsubscribe(callback, method, ...parameters) {
        // Define a function resolve the subscription setup process.
        const subscriptionResolver = async (resolve) => {
            // For each client..
            for (const currentClient in this.clients) {
                // Store client in variable for brevity
                const client = this.clients[currentClient].connection;
                // Log a warning if one of the clients is disconnected, but don't throw an error
                if (client.connection.status !== exports.ConnectionStatus.CONNECTED) {
                    debug.warning(`Client with server ${client.connection.host} could not be reached to unsubscribe`);
                    continue;
                }
                // unsubscribe this client.
                client.unsubscribe(callback, method, ...parameters);
            }
            // Resolve the subscription promise.
            resolve(true);
        };
        // Return a promise that resolves when the subscription is set up.
        return new Promise(subscriptionResolver);
    }
    /**
     * Provides a method to check or wait for the cluster to become ready.
     *
     * @returns a promise that resolves when the required servers are available.
     */
    async ready() {
        // Store the current timestamp.
        const readyTimestamp = Date.now();
        // Define a function to poll for availability of the cluster.
        const availabilityPoller = (resolve) => {
            // Define a function to check if the cluster is ready to be used.
            const connectionAvailabilityVerifier = () => {
                // Check if the cluster is active..
                if (this.status === exports.ClusterStatus.READY) {
                    // Resolve with true to indicate that the cluster is ready to use.
                    resolve(true);
                    // Return after resolving since we do not want to continue the execution.
                    return;
                }
                // Calculate how long we have waited, in milliseconds.
                const timeWaited = (Date.now() - readyTimestamp);
                // Check if we have waited longer than our timeout setting.
                if (timeWaited > this.timeout) {
                    // Resolve with false to indicate that we did not get ready in time.
                    resolve(false);
                    // Return after resolving since we do not want to continue the execution.
                    return;
                }
                // If we are not ready, but have not timed out and should wait more..
                setTimeout(connectionAvailabilityVerifier, 50);
            };
            // Run the initial verification.
            connectionAvailabilityVerifier();
        };
        // Return a promise that resolves when the available clients is sufficient.
        return new Promise(availabilityPoller);
    }
    /**
     * Connects all servers from the cluster and attaches event listeners and handlers
     * for all underlying clients and connections.
     *
     * @throws {Error} if the cluster's version is not a valid version string.
     */
    async startup() {
        // Write a log message.
        debug.cluster('Starting up cluster.');
        // Keep track of all connections
        const connections = [];
        // Loop over all clients and reconnect them if they're disconnected
        for (const clientKey in this.clients) {
            // Retrieve connection information for the client
            const { host, port, scheme } = this.clients[clientKey].connection.connection;
            // Only connect currently unavailable/disconnected clients
            if (this.clients[clientKey].state === exports.ClientState.AVAILABLE) {
                // Warn when a server is already connected when calling startup()
                debug.warning(`Called startup(), but server ${host}:${port} is already connected`);
            }
            else {
                // Call the addServer() function with the existing connection data
                // This effectively reconnects the server and re-instates all event listeners
                connections.push(this.addServer(host, port, scheme));
            }
        }
        // Await all connections
        return Promise.all(connections);
    }
    /**
     * Disconnects all servers from the cluster. Removes all event listeners and
     * handlers from all underlying clients and connections. This includes all
     * active subscriptions, unless retainSubscriptions is set to true.
     *
     * @param {boolean} retainSubscriptions   retain subscription data so they will be restored on reconnection.
     *
     * @returns a list with the disconnection result for every client
     */
    async shutdown(retainSubscriptions = false) {
        // Write a log message.
        debug.cluster('Shutting down cluster.');
        // Set up a list of disconnections to wait for.
        const disconnections = [];
        const disconnectResolver = (resolve) => {
            // Resolve once the cluster is marked as disabled
            this.once('disabled', () => resolve(Promise.all(disconnections)));
            // For each client in this cluster..
            for (const clientIndex in this.clients) {
                // Force disconnection regardless of current status.
                disconnections.push(this.clients[clientIndex].connection.disconnect(true, retainSubscriptions));
            }
        };
        // Return a list of booleans indicating disconnections from all clients
        return new Promise(disconnectResolver);
    }
}

exports.DefaultParameters = DefaultParameters;
exports.ElectrumClient = ElectrumClient;
exports.ElectrumCluster = ElectrumCluster;
exports.ElectrumTransport = ElectrumTransport;
exports.isVersionNegotiated = isVersionNegotiated;
exports.isVersionRejected = isVersionRejected;

},{"async-mutex":7,"debug":10,"events":2,"isomorphic-ws":13,"net":1,"tls":1}],13:[function(require,module,exports){
(function (global){(function (){
// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js

var ws = null

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket
} else if (typeof global !== 'undefined') {
  ws = global.WebSocket || global.MozWebSocket
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket
}

module.exports = ws

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],14:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],15:[function(require,module,exports){
(function (global){(function (){
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],16:[function(require,module,exports){
(function (global){(function (){
const { ElectrumClient } = require("electrum-cash");

global.window.ElectrumClient = ElectrumClient;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"electrum-cash":12}]},{},[16]);
